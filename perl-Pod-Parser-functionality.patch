--- PodParser-1.28/lib/Pod/Select.pm	2003-11-24 16:27:55.000000000 +0100
+++ PodParser-1.28/lib/Pod/Select.pm	2004-06-06 14:16:43.768508000 +0200
@@ -340,7 +340,6 @@
     my $self = shift;
     my @sections = @_;
     local *myData = $self;
-    local $_;
 
 ### NEED TO DISCERN A SECTION-SPEC FROM A RANGE-SPEC (look for m{^/.+/$}?)
 
@@ -369,9 +368,9 @@
     ## Compile each spec
     my $spec;
     for $spec (@sections) {
-        if ( defined($_ = &_compile_section_spec($spec)) ) {
+        if ( defined(my $sel = &_compile_section_spec($spec)) ) {
             ## Store them in our sections array
-            push(@selected_sections, $_);
+            push(@selected_sections, $sel);
         }
         else {
             carp "Ignoring section spec \"$spec\"!\n";
@@ -498,14 +497,14 @@
 
 sub is_selected {
     my ($self, $paragraph) = @_;
-    local $_;
     local *myData = $self;
 
     $self->_init_headings()  unless (defined $myData{_SECTION_HEADINGS});
 
     ## Keep track of current sections levels and headings
-    $_ = $paragraph;
-    if (/^=((?:sub)*)(?:head(?:ing)?|sec(?:tion)?)(\d*)\s+(.*)\s*$/) {
+    if ($paragraph =~
+        /^=((?:sub)*)(?:head(?:ing)?|sec(?:tion)?)(\d*)\s+(.*)\s*$/)
+    {
         ## This is a section heading command
         my ($level, $heading) = ($2, $3);
         $level = 1 + (length($1) / 3)  if ((! length $level) || (length $1));
@@ -581,16 +580,14 @@
 
 sub podselect {
     my(@argv) = @_;
-    my %defaults   = ();
-    my $pod_parser = new Pod::Select(%defaults);
+    my $pod_parser = new Pod::Select();
     my $num_inputs = 0;
     my $output = ">&STDOUT";
-    my %opts = ();
-    local $_;
+    my %opts;
+    local *_;
     for (@argv) {
-        if (ref($_)) {
-            next unless (ref($_) eq 'HASH');
-            %opts = (%defaults, %{$_});
+        if (ref($_) && ref($_) eq 'HASH') {
+            %opts = %{$_};
 
             ##-------------------------------------------------------------
             ## Need this for backward compatibility since we formerly used
@@ -667,9 +664,10 @@
 sub _compile_section_spec {
     my ($section_spec) = @_;
     my (@regexs, $negated);
+    local *_;
 
     ## Compile the spec into a list of regexs
-    local $_ = $section_spec;
+    $_ = $section_spec;
     s|\\\\|\001|g;  ## handle escaped backward slashes
     s|\\/|\002|g;   ## handle escaped forward slashes
 
@@ -750,4 +748,4 @@
 =cut
 
 1;
-
+# vim: ts=4 sw=4 et
--- PodParser-1.28/lib/Pod/Parser.pm	2003-11-24 16:27:08.000000000 +0100
+++ PodParser-1.28/lib/Pod/Parser.pm	2004-06-13 22:04:33.908330176 +0200
@@ -1158,21 +1158,26 @@
     my ($in_fh,  $out_fh) = (gensym, gensym)  if ($] < 5.6);
     my ($close_input, $close_output) = (0, 0);
     local *myData = $self;
-    local $_;
+    local *_;
 
     ## Is $infile a filename or a (possibly implied) filehandle
-    $infile  = '-'  unless ((defined $infile)  && (length $infile));
-    if (($infile  eq '-') || ($infile =~ /^<&(STDIN|0)$/i)) {
-        ## Not a filename, just a string implying STDIN
-        $myData{_INFILE} = "<standard input>";
-        $in_fh = \*STDIN;
-    }
-    elsif (ref $infile) {
+    if (ref $infile) {
+        if (ref($infile) =~ /^(SCALAR|ARRAY|HASH|CODE|REF)$/) {
+            croak "Input from $1 reference not supported!\n";
+        }
         ## Must be a filehandle-ref (or else assume its a ref to an object
         ## that supports the common IO read operations).
         $myData{_INFILE} = ${$infile};
         $in_fh = $infile;
     }
+    elsif (!defined($infile) || !length($infile) || ($infile eq '-')
+        || ($infile =~ /^<&(?:STDIN|0)$/i))
+    {
+        ## Not a filename, just a string implying STDIN
+        $infile ||= '-';
+        $myData{_INFILE} = "<standard input>";
+        $in_fh = \*STDIN;
+    }
     else {
         ## We have a filename, open it for reading
         $myData{_INFILE} = $infile;
@@ -1186,38 +1191,54 @@
     ## the entire document (but *not* if this is an included file). We
     ## determine this by seeing if the input stream stack has been set-up
     ## already
-    ## 
-    unless ((defined $outfile) && (length $outfile)) {
-        (defined $myData{_TOP_STREAM}) && ($out_fh  = $myData{_OUTPUT})
-                                       || ($outfile = '-');
-    }
-    ## Is $outfile a filename or a (possibly implied) filehandle
-    if ((defined $outfile) && (length $outfile)) {
-        if (($outfile  eq '-') || ($outfile =~ /^>&?(?:STDOUT|1)$/i)) {
-            ## Not a filename, just a string implying STDOUT
-            $myData{_OUTFILE} = "<standard output>";
-            $out_fh  = \*STDOUT;
+
+    ## Is $outfile a filename, a (possibly implied) filehandle, maybe a ref?
+    if (ref $outfile) {
+        ## we need to check for ref() first, as other checks involve reading
+        if (ref($outfile) =~ /^(ARRAY|HASH|CODE)$/) {
+            croak "Output to $1 reference not supported!\n";
         }
-        elsif ($outfile =~ /^>&(STDERR|2)$/i) {
-            ## Not a filename, just a string implying STDERR
-            $myData{_OUTFILE} = "<standard error>";
-            $out_fh  = \*STDERR;
+        elsif (ref($outfile) eq 'SCALAR') {
+#           # NOTE: this module isn't a part of the perl distribution,
+#           #       so probably we shouldn't support this case...
+#           require IO::String;
+#           $myData{_OUTFILE} = "$outfile";
+#           $out_fh = IO::String->new($outfile);
+            croak "Output to SCALAR reference not supported!\n";
         }
-        elsif (ref $outfile) {
+        else {
             ## Must be a filehandle-ref (or else assume its a ref to an
             ## object that supports the common IO write operations).
             $myData{_OUTFILE} = ${$outfile};
             $out_fh = $outfile;
         }
+    }
+    elsif (!defined($outfile) || !length($outfile) || ($outfile eq '-')
+        || ($outfile =~ /^>&?(?:STDOUT|1)$/i))
+    {
+        if (defined $myData{_TOP_STREAM}) {
+            $out_fh = $myData{_OUTPUT};
+        }
         else {
-            ## We have a filename, open it for writing
-            $myData{_OUTFILE} = $outfile;
-            (-d $outfile) and croak "$outfile is a directory, not POD input!\n";
-            open($out_fh, "> $outfile")  or
-                 croak "Can't open $outfile for writing: $!\n";
-            $close_output = 1;
+            ## Not a filename, just a string implying STDOUT
+            $outfile ||= '-';
+            $myData{_OUTFILE} = "<standard output>";
+            $out_fh  = \*STDOUT;
         }
     }
+    elsif ($outfile =~ /^>&(STDERR|2)$/i) {
+        ## Not a filename, just a string implying STDERR
+        $myData{_OUTFILE} = "<standard error>";
+        $out_fh  = \*STDERR;
+    }
+    else {
+        ## We have a filename, open it for writing
+        $myData{_OUTFILE} = $outfile;
+        (-d $outfile) and croak "$outfile is a directory, not POD input!\n";
+        open($out_fh, "> $outfile")  or
+             croak "Can't open $outfile for writing: $!\n";
+        $close_output = 1;
+    }
 
     ## Whew! That was a lot of work to set up reasonably/robust behavior
     ## in the case of a non-filename for reading and writing. Now we just
@@ -1774,3 +1795,4 @@
 =cut
 
 1;
+# vim: ts=4 sw=4 et
